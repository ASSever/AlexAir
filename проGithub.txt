https://www.securitylab.ru/analytics/517873.php

Кодовая фраза AlexAir

После того как мы сделали базовые настройки macOS, настало время более подробного рассмотрения набора инструментов, первым из которых станет Git. Мы будем часто использовать Git во всех последующих частях этой серии.
На данный момент Git является наиболее популярной системой управления версиям (в основном, из-за сервиса GitHub), которая предназначена для отслеживания изменений в файлах, и мы, при необходимости, можем восстановить нужную версию в будущем. Git является распределенной системой управления, суть которой заключается в том, что полная версия репозитория хранится в нескольких местах.

Проекты, хранимые на GitHub или в ваших персональных удаленных репозиториях, при клонировании копируются полностью. То есть, когда вы клонируете репозиторий, то копируете все файлы. Далее вы можете вносить и отправлять изменения обратно в свою ветку (форк) проекта, клонировать различные версии или просто скачивать и компилировать текущую версию. Кроме того, вы можете отправлять изменения в специальное хранилище (staging), которые затем могут быть добавлены в главную ветку.

Многие проекты с открытым исходным кодом, включая ядро для Linux и многие популярные хакерские утилиты, хранятся на GitHub. Если еще не зарегистрированы на GitHub, необходимо создать учетную запись.

Git встроен в macOS, поэтому загружать ничего не придется. В этой статье мы рассмотрим самые основы, которых будет достаточно для модификации кода и управления локальными репозиториями. При помощи Git мы сможем клонировать, компилировать, вносить изменения и отправлять исправления ошибок популярных хакерских утилит с открытым исходным кодом.

Шаг 1: Клонирование исходного кода (git clone)

При помощи команды git clone мы будем клонировать проекты, хранимые на GitHub. Вероятно, эту команду вы будете использовать чаще всего, по крайней мере до тех пор, пока не станете разработчиком. Для начала нужно найти репозиторий для клонирования (я выбрал theHarvester) и выполнить следующую команду:

git clone https://github.com/laramies/theHarvester

Рисунок 1: Клонирование проекта theHarvester

Теперь у нас есть копия проекта для персонального использования, но нет необходимых зависимостей, а конкретно – библиотеки для Python. При копировании исходного кода с GitHub подобная ситуация, когда отсутствуют некоторые зависимости - довольно распространенное явление. Если бы мы использовали менеджер пакетов (например, Homebrew), зависимости установились бы автоматически. В нашем же случае мне нужно установить pip (менеджер пакетов для Python-библиотек) и скопировать нужные зависимости.

Шаг 2: Инициализация нового репозитория (git init)

Команда git init позволяет инициализировать директорию в качестве репозитория для Git. Таким образом, нам станет доступна локальная система управления версиями для разрабатываемых проектов. Я создал простейший проект и инициализировал текущую папку в качестве локального репозитория при помощи следующей команды:

git init

Рисунок 2: Инициализация локального репозитария для нового проекта

Во время инициализации директории будет создана папка .git, в которой будут отслеживаться изменения в проекте. На данный момент пока что не отслеживается ни одного файла, поскольку я список для отслеживания пустой.

Шаг 3: Добавление файлов для отслеживания (git add)

После инициализации директории необходимо добавить файлы для отслеживания при помощи следующей команды:

git add *

Рисунок 3: Добавление файлов для отслеживания

Теперь Git будет отслеживать все изменения в файлы, добавленные в список. Когда код отлажен, я могу отправить изменения в проект (см. следующий шаг). Одновременно с этим Git продолжает отслеживать текущие изменения.


Рисунок 4: Жизненный цикл файлов в репозитории

Жизненный цикл файла начинается с добавления в список для отслеживания. Последующее отслеживание происходит до тех пор, пока изменения не будут внесены в проект, и файл не перейдет в состояние «unmodified» (немодифицированный). Внесение изменений в проект говорит о том, что вы удовлетворены кодом файла. Далее жизненный цикл начинается заново.

Шаг 4: Добавление измененного исходного кода в проект (git commit)

После того как все файлы находятся в нужном состоянии вносим изменения при помощи следующей команды:

git commit -a -m 'changed some core UI components'
Команда git commit позволяет отправить внесенные изменения. Флаг –a говорит о том, что нужно отправить изменения во всех отслеживаемых файлах. Флаг –m позволяет добавить текстовое сообщение к отправляемым изменениям.

Рисунок 5: Внесение изменений в проект

Шаг 5: Просмотр состояния репозитория (git status)

Иногда мы откладываем проект на долгое время, или файлов настолько много, что трудно понять происходящее. Для отслеживания текущего состояния репозитория предусмотрена следующая команда:

git status
Я использую эту команду на всех этапах работы с целью просмотра операций, выполняемых Git. Эта команда показывает неотслеживаемые файлы, а также файлы, изменения которых еще не отправлены, и мою текущую рабочую ветку.

Шаг 6: Добавление и тестирование новых функций (git branch)

При помощи отдельных веток мы можем добавлять и тестировать новые функции без внесения изменений в текущий и стабильный код. Например, у меня есть файл hackThePlanet.py, который стабильно работает, но мне захотелось протестировать новые функции без внесения изменений в текущий код. В этом случае можно воспользоваться следующей командой:

git branch experimental
Команда выше создает новую ветку в проекте. Затем необходимо переключиться на новую экспериментальную ветку:

git checkout experimental
Альтернативная команда, которая объединяет две предыдущие:

git checkout -b experimental
Эта команда создает и переключает нас в новую ветку, которая указана после флага –b.

Рисунок 6: Создание новой ветки для экспериментов

Затем я добавлю новые экспериментальные функции, проверю работоспособность кода и отправлю изменения в новую ветку. При работе в команде возможно использование нескольких веток – одна ветка для новых элементов интерфейса, другая – для исправления ошибок, третья – для добавления новых функций.

Шаг 7: Добавление изменений в основную ветку (git merge)

После того как экспериментальные изменение протестированы, настало время объединить ветки. Вначале переключаемся в основную ветку:

git checkout master
Далее объединяем основную и экспериментальную ветку:

git merge experimental

Рисунок 7: Объединение двух ветвей

Теперь основная ветвь содержит новые функции и другие изменения из экспериментальной ветки. Далее я могу продолжить добавление и отладку новых функций в экспериментальной ветке или создать новую ветвь.

Заключение

В этой статье мы рассмотрели базовые методы работы с Git, как, например, работу с локальными репозиториями. У этой утилиты есть еще много других полезных функций, которых мы не коснулись, особенно в сочетание с сервисом GitHub.

Даже если вы не будете использовать эти возможности, важно знать о том, что подобные функции существую. Во время пентестов вам может понадобиться модификация кода или копирование репозитория для последующей работы в локальной системе. Если вы сталкиваетесь с подобным, материалы из этой статьи помогут сделать вашу работу более организованной. У git есть очень хорошая документация. Команда gitbranch --help позволяет ознакомиться с документацией на конкретную команду.

В следующей статье мы рассмотрим менеджер пакетов Homebrew.
Подробнее: https://www.securitylab.ru/analytics/492395.php